import { Node, Schema } from "@tiptap/pm/model";
import { defaultMarkdownParser, MarkdownSerializer, MarkdownSerializerState } from "prosemirror-markdown";
import { defaultMarkdownSerializer } from "prosemirror-markdown";
import YAML from "yaml";
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkGfm from "remark-gfm";
import remarkStringify from "remark-stringify";
import { JSONContent } from "@tiptap/core";
import packageJson from "../../../../package.json";
import { useContentStore } from "@/core/stores/ContentStore";

const appVersion = packageJson.version;

// Helper: Prepend frontmatter to markdown content
export function addVersionFrontmatter(
  markdownContent: string,
  options?: {
    appVersion?: string;
    customFields?: Record<string, any>;
  },
): string {
  const storedContent = useContentStore.getState();

  let generatedAt;

  const regex = /generatedAt:\s*(.*?)\s*---/;
  const match = storedContent.content.match(regex);
  if (match) {
    generatedAt = match[1].trim();
  } else {
    generatedAt = null;
  }

  // Build the frontmatter object with extra metadata
  const frontmatterObj = {
    version: appVersion,
    generatedBy: "Voiden app",
    note: "This file is auto-generated by the Voiden app",
    generatedAt: generatedAt || new Date().toISOString(),
    ...options?.customFields,
  };

  // Convert the object to YAML
  const frontmatterYaml = YAML.stringify(frontmatterObj);

  // Prepend the frontmatter to the markdown content
  return `---\n${frontmatterYaml}---\n\n${markdownContent}`;
}

function stripFrontmatter(markdown: string): string {
  // Check if the markdown starts with the frontmatter delimiter.
  if (markdown.startsWith("---")) {
    // Split on the delimiter.
    const parts = markdown.split("---");
    if (parts.length >= 3) {
      // parts[0] is empty, parts[1] is the frontmatter,
      // and parts[2] onward is the actual markdown content.
      return parts.slice(2).join("---").trimStart();
    }
  }
  return markdown;
}

// helper: convert snake_case node names to camelCase
const convertNodeNames = (node: any): any => {
  const snakeToCamel = (s: string) => s.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  if (node.type) {
    node.type = snakeToCamel(node.type);
  }
  if (node.content && Array.isArray(node.content)) {
    node.content = node.content.map(convertNodeNames);
  }
  return node;
};

// Helper: Simplify a ProseMirror table node (in JSON form) into a minimal YAML schema.
// New version of simplifyTableNode
function simplifyTableNode(tableJson: JSONContent) {
  const simplified = { type: "table", rows: [] };

  if (!tableJson.content || !Array.isArray(tableJson.content)) return simplified;

  // Process each tableRow
  tableJson.content.forEach((rowNode) => {
    if (rowNode.type !== "tableRow") return;
    const simpleRow: any = {};

    if (rowNode.attrs && Object.keys(rowNode.attrs).length > 0) {
      simpleRow.attrs = rowNode.attrs;
    }

    simpleRow.row = [];
    if (rowNode.content && Array.isArray(rowNode.content)) {
      rowNode.content.forEach((cellNode) => {
        if (cellNode.type !== "tableCell" && cellNode.type !== "tableHeader") return;

        let cellValue: any;
        // If the cell contains a single paragraph:
        if (cellNode.content && cellNode.content.length === 1 && cellNode.content[0].type === "paragraph") {
          const para = cellNode.content[0];
          // If the paragraph has a single text node, simply use its text.
          if (para.content && para.content.length === 1 && para.content[0].type === "text") {
            cellValue = para.content[0].text;
          } else {
            // Otherwise, iterate over each child. If it's a text node, return its text;
            // if it's a custom node (like fileLink), return the full node.
            cellValue = para.content?.map((child) => {
              if (child.type === "text") {
                return child.text;
              } else {
                return child; // preserves fileLink node (or any inline custom node)
              }
            });
            // If the array happens to have only one string element, collapse it.
            if (cellValue?.length === 1 && typeof cellValue[0] === "string") {
              cellValue = cellValue[0];
            }
          }
        } else {
          // Fallback: use the cell's textContent if not a simple paragraph.
          cellValue = cellNode.textContent || "";
        }
        simpleRow.row.push(cellValue);
      });
    }
    simplified.rows.push(simpleRow);
  });
  return simplified;
}

// Helper: recursively collapse content arrays that are a single text node.
// Helper: Recursively collapse content arrays that are a single text node.
function collapseTextContent(node: JSONContent) {
  if (!node || typeof node !== "object") return node;

  if (Array.isArray(node.content)) {
    // If the array has exactly one element that is a text node, collapse it.
    if (node.content.length === 1 && node.content[0].type === "text" && typeof node.content[0].text === "string") {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (node as any).content = node.content[0].text;
    } else {
      // Otherwise, recursively process each child.
      node.content = node.content.map((child) => collapseTextContent(child));
    }
  }
  return node;
}

const fallback = (state: MarkdownSerializerState, node: Node) => {
  // Determine the language to use in the code block.
  const lang = node.attrs && node.attrs.lang ? node.attrs.lang : "void";
  state.write("```" + lang + "\n");
  state.write("---\n");

  // Get the full node as JSON.
  let nodeJson = node.toJSON();

  // If there is a content array at the first level, process each child.
  if (nodeJson.content && Array.isArray(nodeJson.content)) {
    nodeJson.content = nodeJson.content.map((child) => {
      if (child.type === "table") {
        // Replace the table child with its simplified version.
        return simplifyTableNode(child);
      }
      // Otherwise, collapse single-text node arrays.
      return collapseTextContent(child);
    });
  }

  // Also, collapse any single text arrays on the top level.
  nodeJson = collapseTextContent(nodeJson);

  // Convert the (transformed) JSON to YAML.
  const nodeYaml = YAML.stringify(nodeJson);
  state.write(nodeYaml);

  state.write("---\n");
  state.write("```\n");
};

const nodeNameMap = {
  // keep this for serializer mapping if needed
  bulletList: "bullet_list",
  orderedList: "ordered_list",
  codeBlock: "code_block",
  hardBreak: "hard_break",
  horizontalRule: "horizontal_rule",
  listItem: "list_item",
};

const codeBlockSerializer = (state: MarkdownSerializerState, node: Node) => {
  const lang = node.attrs.language || "";
  const body = node.attrs.body || node.textContent || "";
  state.write("```" + lang + "\n");
  state.text(body, false);
  if (!body.endsWith("\n")) state.write("\n");
  state.write("```");
  state.closeBlock(node);
};

// --- NEW: Custom serializer for paragraphs ---
// When a paragraph is empty it outputs two newlines, otherwise it renders normally.
const paragraphSerializer = (state: MarkdownSerializerState, node: Node) => {
  if (node.type.name !== "paragraph") return;
  if (node.content.size === 0) {
    state.write("\n");
  } else {
    state.renderInline(node);
    state.closeBlock(node);
  }
};

// Inline serializer for fileLink nodes.
// Outputs [@filename](filePath) so it survives markdown round-trips.
// The @ prefix distinguishes file links from regular markdown links.
const fileLinkSerializer = (state: MarkdownSerializerState, node: Node) => {
  const filename = node.attrs.filename || "";
  const filePath = node.attrs.filePath || "";
  const isExternal = node.attrs.isExternal;
  state.write(`[@${filename}](${filePath}${isExternal ? ' "external"' : ""})`);
};

const buildNodeSerializers = (schema: any) => {
  const serializers: { [node: string]: any } = {};
  Object.keys(schema.nodes).forEach((nodeName) => {
    if (nodeName === "codeBlock") {
      serializers[nodeName] = codeBlockSerializer;
    } else if (nodeName === "paragraph") {
      serializers[nodeName] = paragraphSerializer;
    } else if (nodeName === "fileLink") {
      serializers[nodeName] = fileLinkSerializer;
    } else {
      const mappedName = nodeNameMap[nodeName] || nodeName;
      if (defaultMarkdownSerializer.nodes[mappedName]) {
        serializers[nodeName] = defaultMarkdownSerializer.nodes[mappedName];
      } else {
        serializers[nodeName] = fallback;
      }
    }
  });
  return serializers;
};

const buildMarkSerializers = () => {
  const defaultMarks = defaultMarkdownSerializer.marks;

  return {
    bold: defaultMarks.strong,
    italic: defaultMarks.em,
    code: defaultMarks.code,
    link: defaultMarks.link,
    strike: {
      open: "~~",
      close: "~~",
      mixable: true,
      expelEnclosingWhitespace: true,
    },
  };
};

export const createMarkdownSerializer = (schema: Schema) => {
  const nodes = buildNodeSerializers(schema);
  const marks = buildMarkSerializers();
  return new MarkdownSerializer(nodes, marks, { strict: false });
};

// NEW Helper: Inflate a simplified table node back to full ProseMirror JSON.
function inflateTableNode(simplified) {
  const tableNode = {
    type: "table",
    content: [],
  };

  if (!simplified.rows || !Array.isArray(simplified.rows)) return tableNode;

  simplified.rows.forEach((rowObj) => {
    const tableRow = {
      type: "tableRow",
      attrs: rowObj.attrs || {},
      content: [],
    };

    (rowObj.row || []).forEach((cellValue) => {
      // Create a paragraph node for the cell.
      const paragraph = {
        type: "paragraph",
        content: [],
      };

      if (cellValue === null || cellValue === undefined) {
        // Handle null/undefined values explicitly - leave content as empty array
      } else if (typeof cellValue === "string") {
        paragraph.content.push({
          type: "text",
          text: cellValue,
        });
      } else if (Array.isArray(cellValue)) {
        cellValue.forEach((item) => {
          if (typeof item === "string") {
            paragraph.content.push({
              type: "text",
              text: item,
            });
          } else if (typeof item === "object") {
            // Assume it's already a node (like fileLink) and include it as-is.
            paragraph.content.push(item);
          }
        });
      } else if (typeof cellValue === "object") {
        paragraph.content.push(cellValue);
      }

      const tableCell = {
        type: "tableCell",
        attrs: { colspan: 1, rowspan: 1, colwidth: null },
        content: [paragraph],
      };
      tableRow.content.push(tableCell);
    });

    tableNode.content.push(tableRow);
  });

  return tableNode;
}

// -------------------------------------------------------------------------
// NEW Helper: Recursively inflate a simplified node back into full ProseMirror JSON.
// This helper does two things:
//   1. If a node is a simplified table (has type "table" and a "rows" property),
//      it is inflated via inflateTableNode.
//   2. If a node's content is a string (because it was collapsed), it is wrapped back
//      into an array with a text node. Otherwise, if the content is an array, we process recursively.
function inflateSimplifiedNode(node) {
  if (!node || typeof node !== "object") return node;

  // If this node is a simplified table, inflate it.
  if (node.type === "table" && node.rows) {
    node = inflateTableNode(node);
  }

  // Process the content recursively.
  if (typeof node.content === "string") {
    // If content was collapsed to a simple string, wrap it in a text node.
    node.content = [{ type: "text", text: node.content }];
  } else if (Array.isArray(node.content)) {
    node.content = node.content.map((child) => inflateSimplifiedNode(child));
  }

  return node;
}

// -------------------------------------------------------------------------
// Updated processCubeBlockText: now inflate simplified table and text content recursively.
const processCubeBlockText = (text: string, schema: any): JSONContent => {
  const rawCubeText = text;
  const lines = text.split("\n");

  // Verify that the voiden-wrapper block starts with the expected YAML frontmatter delimiter.
  if (lines[0].trim() !== "---") {
    throw new Error("expected cube header to start with ---");
  }
  const headerEnd = lines.indexOf("---", 1);
  if (headerEnd === -1) {
    throw new Error("missing cube header closing ---");
  }

  // Parse the YAML content (which represents the full node JSON, possibly in simplified form).
  const headerYaml = lines.slice(1, headerEnd).join("\n");
  let nodeJson = YAML.parse(headerYaml);

  // If the node's type is not present in the schema, fall back to a codeBlock.
  if (!schema.nodes[nodeJson.type]) {
    return {
      type: "codeBlock",
      attrs: { language: "void" },
      content: [{ type: "text", text: rawCubeText }],
    };
  }

  // Recursively inflate the node (for both tables and collapsed text).
  nodeJson = inflateSimplifiedNode(nodeJson);

  return nodeJson;
};

const processCubeNode = (node: any, schema: any) => {
  try {
    return processCubeBlockText(node.value, schema);
  } catch (e) {
    // console.error("error processing cube node:", e);
    return {
      type: "paragraph",
      content: [{ type: "text", text: node.value }],
    };
  }
};

// updated helper: always output table cells as tableCell, never tableHeader
const parseGfmTable = (text: string): JSONContent | null => {
  const lines = text.split("\n").filter((line) => line.trim().length);
  if (lines.length < 2) return null; // need at least header and separator

  // parse header row—but force cells to be tableCell (not tableHeader)
  const headerCells = lines[0]
    .split("|")
    .slice(1, -1) // remove the empty string before the first and after the last pipe
    .map((c) => c.trim());
  const tableRows: any[] = [];
  const headerRow = {
    type: "tableRow",
    attrs: {},
    content: headerCells.map((cellText) => ({
      type: "tableCell",
      attrs: { colspan: 1, rowspan: 1, colwidth: null },
      content: [
        {
          type: "paragraph",
          content: cellText
            ? [
                {
                  type: "text",
                  text: cellText,
                },
              ]
            : [],
        },
      ],
    })),
  };
  tableRows.push(headerRow);

  // skip separator row (assumed to be second row) and convert remaining rows similarly
  for (let i = 2; i < lines.length; i++) {
    const rowCells = lines[i]
      .split("|")
      .slice(1, -1)
      .map((c) => c.trim());
    const row = {
      type: "tableRow",
      attrs: {},
      content: rowCells.map((cellText) => ({
        type: "tableCell",
        attrs: { colspan: 1, rowspan: 1, colwidth: null },
        content: [
          {
            type: "paragraph",
            content: cellText
              ? [
                  {
                    type: "text",
                    text: cellText,
                  },
                ]
              : [],
          },
        ],
      })),
    };
    tableRows.push(row);
  }
  return {
    type: "table",
    content: tableRows,
  };
};

function applyMarkRecursively(node: JSONContent, markType: string, schema?: any, definitions?: Record<string, { url: string; title?: string }>): JSONContent[] {
  const children = node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];

  // Check if the mark type exists in the schema
  const markExists = !schema || schema.marks[markType];

  return children
    .filter((child: JSONContent) => child !== null && child !== undefined) // Filter out null/undefined first
    .map((child: JSONContent) => {
      if (child.type === "text") {
        // Don't create empty text nodes
        if (!child.text || child.text === "") return null;
        return {
          ...child,
          marks: markExists ? [...(child.marks || []), { type: markType }] : (child.marks || []),
        };
      } else if (child.content && Array.isArray(child.content)) {
        return {
          ...child,
          content: child.content
            .filter((c: JSONContent) => c !== null && c !== undefined)
            .map((c: JSONContent) => {
              if (c.type === "text") {
                // Don't create empty text nodes
                if (!c.text || c.text === "") return null;
                return {
                  ...c,
                  marks: markExists ? [...(c.marks || []), { type: markType }] : (c.marks || []),
                };
              }
              return c;
            })
            .filter(Boolean),
        };
      } else {
        return child;
      }
    })
    .filter(Boolean); // Remove any null children
}

// update mdast converter: when converting table cells, always use tableCell
const convertMdastNode = (node: any, schema?: any, definitions?: Record<string, { url: string; title?: string }>): JSONContent => {
  switch (node.type) {
    case "heading":
      return {
        type: "heading",
        attrs: {
          level: node.depth,
        },
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "blockquote":
      return {
        type: "blockquote",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "table":
      return {
        type: "table",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "tableRow":
      return {
        type: "tableRow",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "tableCell":
    case "tableHeader": {
      const cellContent =
        node.children && node.children.length
          ? node.children[0].type === "paragraph"
            ? node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean)
            : [
                {
                  type: "paragraph",
                  content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
                },
              ]
          : [
              {
                type: "paragraph",
                content: [],
              },
            ];
      return {
        type: "tableCell",
        attrs: { colspan: 1, rowspan: 1, colwidth: null },
        content: cellContent,
      };
    }
    case "paragraph":
      return {
        type: "paragraph",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "listItem":
      return {
        type: "listItem",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "list":
      return {
        type: node.ordered ? "orderedList" : "bulletList",
        content: node.children.flatMap((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean),
      };
    case "text":
      return {
        type: "text",
        text: node.value,
      };
    case "link": {
      // Convert link node to text node with link mark
      const text = node.children?.map((child: any) => child.value || "").join("") || "";

      // Detect file links: [@filename](filePath) — text starts with @
      if (text.startsWith("@") && text.length > 1) {
        return {
          type: "fileLink",
          attrs: {
            filePath: node.url || "",
            filename: text.substring(1),
            isExternal: node.title === "external",
          },
        };
      }

      return {
        type: "text",
        text,
        marks: [
          {
            type: "link",
            attrs: {
              href: node.url,
              target: "_blank",
              rel: "noopener noreferrer nofollow",
              class: null,
            },
          },
        ],
      };
    }
    case "linkReference": {
      // Reference-style links - resolve using definitions
      if (definitions && definitions[node.identifier]) {
        const def = definitions[node.identifier];
        // Extract text from children, or use empty array if no children
        const children = node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];

        // If we have text content, apply the link mark
        if (children.length > 0) {
          return children.map((child: any) => {
            if (child.type === "text") {
              return {
                ...child,
                marks: [
                  ...(child.marks || []),
                  {
                    type: "link",
                    attrs: {
                      href: def.url,
                      target: "_blank",
                      rel: "noopener noreferrer nofollow",
                      class: null,
                    },
                  },
                ],
              };
            }
            return child;
          });
        }
        // If no children, skip this node
        return null;
      }
      // If not found in definitions, render as plain text (if we have content)
      const children = node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];
      if (children.length > 0 && children[0].type === "text") {
        return {
          type: "text",
          text: `[${children[0].text}][${node.identifier || ''}]`
        };
      }
      return null;
    }
    case "inlineCode":
      return {
        type: "text",
        text: node.value,
        marks: [{ type: "code" }],
      };
    case "strong": {
      const result = applyMarkRecursively(node, "bold", schema, definitions);
      // If no result or empty result, fall back to plain text
      if (!result || result.length === 0) {
        return node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];
      }
      return result;
    }
    case "emphasis": {
      // Check if italic mark exists in schema, if not fall back to plain text
      if (schema && !schema.marks.italic) {
        return node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];
      }
      const result = applyMarkRecursively(node, "italic", schema, definitions);
      // If no result or empty result, fall back to plain text
      if (!result || result.length === 0) {
        return node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];
      }
      return result;
    }
    case "delete": {
      const result = applyMarkRecursively(node, "strike", schema, definitions);
      // If no result or empty result, fall back to plain text
      if (!result || result.length === 0) {
        return node.children?.flatMap((child: any) => convertMdastNode(child, schema, definitions)) || [];
      }
      return result;
    }
    case "break":
      return {
        type : "text",
        text : "\n"
      }
    case "code":
      return {
        type: "codeBlock",
        attrs: {
          language: node.lang || "plaintext",
          body: node.value || ""
        }
      }
    case "image":
      return {
        type : "image",
        attrs : {
          src : node.url,
          alt: node.alt,
          title: node.title
        }
      }
    case "imageReference":
      // Reference-style images - resolve using definitions
      if (definitions && definitions[node.identifier]) {
        const def = definitions[node.identifier];
        return {
          type: "image",
          attrs: {
            src: def.url,
            alt: node.alt || '',
            title: def.title
          }
        };
      }
      // If not found in definitions, render as text
      return {
        type: "text",
        text: `![${node.alt || ''}][${node.identifier || ''}]`
      }
    case "definition":
      // Link/image definitions - these are metadata and shouldn't render
      return null;
    default:
      if (node.children) {
        return {
          type: node.type,
          content: node.children.map((child: any) => convertMdastNode(child, schema, definitions)).filter(Boolean)
        };
      }
      // Don't create empty text nodes
      if (node.value && node.value !== "") {
        return { type: "text", text: node.value };
      }
      return null;
  }
};

const EMPTY_LINE_MARKER = "%%EMPTY_LINE%%";

// --- Helpers for protecting fallback blocks ---

function extractFallbackBlocks(markdown: string) {
  const fallbackBlocks: string[] = [];
  const placeholderTemplate = "%%FALLBACK_BLOCK_%INDEX%%";
  const fallbackRegex = /(^```(?:\S+)?\n---\n[\s\S]+?\n```)/gm;
  const newMarkdown = markdown.replace(fallbackRegex, (match) => {
    const placeholder = placeholderTemplate.replace("%INDEX%", fallbackBlocks.length.toString());
    fallbackBlocks.push(match);
    return placeholder;
  });
  return { newMarkdown, fallbackBlocks, placeholderTemplate };
}

function reinsertFallbackBlocks(markdown: string, fallbackBlocks: string[], placeholderTemplate: string) {
  let result = markdown;
  fallbackBlocks.forEach((block, i) => {
    const placeholder = placeholderTemplate.replace("%INDEX%", i.toString());
    result = result.replace(placeholder, block);
  });
  return result;
}

// --- NEW: Updated insertEmptyLineMarkers function ---
// This version always outputs at least one blank line when a group of blank lines is encountered,
// and for each extra blank line (beyond the first) it inserts a marker.
function insertEmptyLineMarkers(markdown: string) {
  const lines = markdown.split(/\r?\n/);
  const resultLines: string[] = [];
  let previousWasEmpty = false;

  for (const line of lines) {
    if (line.trim() === "") {
      if (previousWasEmpty) {
        resultLines.push("%%EMPTY_LINE%%\n");
      } else {
        resultLines.push("");
      }
      previousWasEmpty = true;
    } else {
      resultLines.push(line);
      previousWasEmpty = false;
    }
  }
  return resultLines.join("\n");
}
// Helper function to fix mark types from prosemirror-markdown to TipTap schema
// Converts 'em' -> 'italic' and 'strong' -> 'bold'
function fixMarkTypes(content: any[]): any[] {
  if (!content || !Array.isArray(content)) return content;

  return content.map((node) => {
    if (!node) return node;

    // Fix marks on this node
    if (node.marks && Array.isArray(node.marks)) {
      node.marks = node.marks.map((mark: any) => {
        if (mark.type === 'em') {
          return { ...mark, type: 'italic' };
        } else if (mark.type === 'strong') {
          return { ...mark, type: 'bold' };
        }
        return mark;
      });
    }

    // Recursively fix marks in child content
    if (node.content && Array.isArray(node.content)) {
      node.content = fixMarkTypes(node.content);
    }

    return node;
  });
}

// --- UPDATED parseMarkdown function ---
// Instead of re-stringifying non-marker paragraphs (which was merging them),
// we now directly convert paragraphs using convertMdastNode.
export function parseMarkdown(markdown: string, schema: Schema) {
  // First, strip out the frontmatter section.
  const markdownWithoutFrontmatter = stripFrontmatter(markdown);
  // Preprocess: insert markers for extra blank lines.
  const preprocessedMarkdown = insertEmptyLineMarkers(markdownWithoutFrontmatter);
  // Parse with Unified (using remarkParse and remarkGfm).
  const mdast = unified().use(remarkParse).use(remarkGfm).parse(preprocessedMarkdown);

  // Collect all definitions (for reference-style links/images)
  const definitions: Record<string, { url: string; title?: string }> = {};
  mdast.children.forEach((child: any) => {
    if (child.type === "definition") {
      definitions[child.identifier] = {
        url: child.url,
        title: child.title,
      };
    }
  });

  const result: any[] = [];
  mdast.children.forEach((child: any) => {
    if (child.type === "paragraph") {
      // Check if paragraph contains any images
      // TipTap's Image extension is block-level by default, so images cannot be inside paragraphs
      const hasImages = child.children && child.children.some((c: any) => c.type === "image");

      if (hasImages) {
        // Split paragraph content: separate text/inline nodes from images
        const textNodes: any[] = [];
        const imageNodes: any[] = [];

        child.children.forEach((c: any) => {
          if (c.type === "image") {
            imageNodes.push(c);
          } else {
            textNodes.push(c);
          }
        });

        // If there's text content, add it as a paragraph
        if (textNodes.length > 0) {
          result.push({
            type: "paragraph",
            content: textNodes.flatMap((n: any) => convertMdastNode(n, schema, definitions)),
          });
        }

        // Add images as block-level nodes
        imageNodes.forEach((imageNode: any) => {
          result.push(convertMdastNode(imageNode, schema, definitions));
        });

        return;
      }

      // Join all text from children to get the full text, but preserve inline code blocks
      const fullText = child.children
        ? child.children
            .map((n: any) => {
              if (n.type === "inlineCode") {
                return `\`${n.value}\``;
              }
              return n.value || "";
            })
            .join("")
        : "";

      if (fullText.includes(EMPTY_LINE_MARKER)) {
        // Instead of simply splitting and pushing one paragraph per part,
        // we rebuild the node sequence so that each marker occurrence inserts
        // a single empty paragraph.
        const parts = fullText.split(EMPTY_LINE_MARKER);
        const newNodes: any[] = [];
        for (let i = 0; i < parts.length; i++) {
          // For every marker occurrence (i > 0), insert an empty paragraph.
          if (i > 0) {
            newNodes.push({
              type: "paragraph",
              content: [],
            });
          }
          // If this piece has some actual text, add it as a separate paragraph.
          const trimmed = parts[i].trim();
          if (trimmed) {
            // Parse the text to handle inline code blocks
            const parsed = defaultMarkdownParser.parse(trimmed).toJSON();
            if (parsed.content && parsed.content.length) {
              // Fix mark types: convert 'em' to 'italic' and 'strong' to 'bold'
              const fixedContent = fixMarkTypes(parsed.content[0].content);
              newNodes.push({
                type: "paragraph",
                content: fixedContent,
              });
            }
          }
        }
        // If nothing was added (i.e. the paragraph was only markers/whitespace),
        // then add one empty paragraph.
        if (newNodes.length === 0) {
          newNodes.push({
            type: "paragraph",
            content: [],
          });
        }
        newNodes.forEach((node) => result.push(node));
      } else {
        // For a normal paragraph, convert it directly.
        result.push(convertMdastNode(child, schema, definitions));
      }
    } else if (child.type === "code") {
      if (child.lang === "void") {
        result.push(processCubeNode(child, schema));
      } else {
        // Regular code block
        result.push({
          type: "codeBlock",
          attrs: {
            language: child.lang || "plaintext",
            body: child.value || ""
          }
        });
      }
    } else if (child.type === "table") {
      result.push(convertMdastNode(child, schema, definitions));
    } else if (child.type === "heading") {
      result.push(convertMdastNode(child, schema, definitions));
    } else if (child.type === "blockquote") {
      result.push(convertMdastNode(child, schema, definitions));
    } else if (child.type === "list") {
      result.push(convertMdastNode(child, schema, definitions));
    } else if (child.type === "image") {
      result.push(convertMdastNode(child, schema, definitions));
    } else if (child.type === "definition") {
      // Skip definition nodes - they're already collected
      return;
    }
    else {
      // For any other node types, fall back to re-stringifying and re-parsing.
      const childMarkdown = unified().use(remarkGfm).use(remarkStringify).stringify(child);
      if (!childMarkdown.trim()) {
        return; // skip empty nodes
      } else {
        const parsed = defaultMarkdownParser.parse(childMarkdown).toJSON();
        if (child.type === "code" && parsed.content) {
          parsed.content.forEach((node: any) => {
            if (node.type === "codeBlock") {
              // Extract text content and store in body attribute
              const textContent = node.content?.map((c: any) => c.text || "").join("") || child.value || "";
              node.attrs = {
                ...node.attrs,
                language: child.lang || "plaintext",
                body: textContent
              };
              // Remove content since we store everything in body
              delete node.content;
            }
          });
        }
        if (parsed.content && parsed.content.length) {
          // Fix mark types before pushing to result
          const fixedContent = parsed.content.map((node: any) => {
            const converted = convertNodeNames(node);
            // Recursively fix marks in the entire node tree
            if (converted.content) {
              converted.content = fixMarkTypes(converted.content);
            }
            return converted;
          });
          result.push(...fixedContent);
        }
      }
    }
  });
  // handle empty markdown
  if (result.length === 0) {
    return { type: "doc", content: [{ type: "paragraph", content: undefined }] };
  }
  return { type: "doc", content: result };
}
